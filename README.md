# Docker Lab

## Задание
Цель лабораторной работы: собрать из исходного кода и запустить в Docker рабочее приложение с базой данных (любое open-source на выбор: Java, Python/Django/Flask, Golang).

### Требования:
1. Образ должен быть **легковесным**.
2. Использовать базовые **легковесные образы** (например, Alpine).
3. Вся конфигурация приложения должна быть реализована через **переменные окружения**.
4. **Статика** (зависимости) должна быть вынесена в **внешний том** (`volume`).
5. Создать файл `docker-compose.yml` для **сборки** и **запуска** приложения.
6. В `docker-compose.yml` необходимо использовать базу данных (например, PostgreSQL, MySQL, MongoDB и т.д.).
7. При старте приложения должны быть учтены **автоматические миграции**.
8. Контейнер должен запускаться от **непривилегированного пользователя**.
9. После установки всех необходимых утилит, должен **очищаться кеш**.

---

### Описание работы

Это мини-приложение для управления задачами или заметками, реализующее базовые функции:

- **Добавление новых заметок** в базу данных.
- **Просмотр полного списка заметок**, сохранённых в базе данных PostgreSQL.

Все переменные вынесены в файл `.env`

Пример интерфейса:  
![Интерфейс приложения](/images/example-site.png)



### Dockerfile
Контейнер будет основываться на базовом образе Python 3.10. Для минимизации использования памяти выбрана версия на основе Alpine.
```Docker
FROM python:3.10-alpine
```
Далее создается рабочая директория `/app`, где будут находиться все файлы приложения:
```Docker
WORKDIR /app
```
Создание нового **непривилегированного** пользователя, от имени которого будет запускаться программа.
```Docker
RUN adduser --disabled-password appuser
```
Копируем файл с необходимыми библиотеками отдельным слоём, так как библиотеки не так часто обновляются и данный слой будет закеширован.
```Docker
COPY requirements.txt /app/
```
Удаляем весь кеш и устанавливаем зависимости
```Docker
RUN pip install --no-cache-dir -r requirements.txt && \
    rm -rf /root/.cache/pip && \
    rm -rf /var/cache/apk/*
```
Копируем остальное содержимое текущей директории, объявляем необходимый порт, по которому будет работать приложение, и переходим на созданного пользователя.
```Docker
COPY . /app/
EXPOSE ${APP_PORT}
USER appuser
```
Запускаем файл с командами миграции и запуска приложения.
```Docker
ENTRYPOINT [ "./entrypoints.sh" ]
```
Содержимое `entrypoints.sh`
```Sh
#!/bin/sh
alembic upgrade head
python main.py
```

### Docker-compose
```yml
version: "3"

services:
  postgres_db:
    image: postgres:17-alpine
    container_name: pg_db
    environment:
      POSTGRES_DB: "pg_db"
      POSTGRES_USER: "egor"
      POSTGRES_PASSWORD: "root123"
    ports:
      - "5432:5432"
    volumes:
      - pg_data:/var/lib/postgresql/data

  app:
    build:
      context: .
      dockerfile: Dockerfile
    environment:
      USER: "egor"
      PASSWORD: "root123"
      SERVER: "postgres_db"
      DATABASE: "pg_db"
      PORT: 5432
      APP_HOST: 0.0.0.0
      APP_PORT: 5000
    ports:
      - "5000:5000"
    volumes:
      - static_volume:/app/static
      - .:/app
    depends_on:
      - postgres_db
    restart: on-failure:3
    


volumes:
  pg_data:
  static_volume:
```
### Описание:

1. **Сервис `postgres_db`**:
   - В качестве образа используется **легковесный** образ `postgres:17-alpine`.
   - Мы указываем **переменные окружения**, необходимые для работы базы данных: `POSTGRES_DB`, `POSTGRES_USER` и `POSTGRES_PASSWORD`.
   - Порты **5432** пробрасываются для подключения к базе данных.
   - В **volumes** монтируем том `pg_data`, который сохраняет данные базы между перезапусками контейнера.
   - Устанавливаем переменные окружения, которые определяют имя базы данных, пользователя и пароль.

2. **Сервис `app`**:
   - Для приложения используется собственная сборка, указав путь до `Dockerfile`.
   - Приложение подключается к базе данных с помощью переменных окружения, таких как `USER`, `PASSWORD`, `SERVER`, `DATABASE` и др.
   - Порты **5000** пробрасываются для взаимодействия с приложением.
   - **Внешние тома** для статики и кода приложения: `static_volume:/app/static` и `.:/app`.
   - Контейнер перезапускается в случае неудачных попыток запуска  `restart: on-failure:3`.
   - Используется опция `depends_on`, чтобы приложение запускалось только после старта базы данных.
   
В проекте вынесены тома для хранения данных и статики отдельно, что позволяет использовать их для взаимодействия между контейнерами. 